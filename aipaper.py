# -*- coding: utf-8 -*-
"""“AIPaper-Rewrite.ipynb”的副本

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jkwX56UsEJqYfZV_oPzCAc3c7NKBIOjv

# Planning
## Rewrite
1. use EXA search
2. add human input pick up paper from 5
3. save output to pydantic as json
* title
* description 500: clearation, paper title, author, link
* text prompt to NLM
4. send pdf link to NLM API
5. ask human input when should check status or check every 1 min
6. get audio convert to mp3
7. publish json with mp3 file to podbean

# Setup Newsroom Crew

## Installation and Tools
"""

!pip install crewai
!pip install crewai crewai-tools

!pip install pydub

!pip install crewai[agentops]

from google.colab import userdata

from crewai import Agent, Task, Crew, Process
import os
import agentops
agentops.start_session(userdata.get('AGENTOPS_API_KEY'))

os.environ['OPENAI_MODEL_NAME'] = userdata.get('OPENAI_MODEL_NAME')
os.environ['OPENAI_API_KEY'] = userdata.get('OPENAI_API_KEY')
os.environ["SERPER_API_KEY"] = userdata.get('SERPER_API_KEY')
os.environ["EXA_API_KEY"] = userdata.get('EXA_API_KEY')
os.environ["AGENTOPS_API_KEY"] = userdata.get('AGENTOPS_API_KEY')


# set up tools

from crewai_tools import DirectoryReadTool, \
                         FileReadTool, \
                         WebsiteSearchTool, \
                         ScrapeWebsiteTool, \
                         BaseTool, \
                         EXASearchTool

directory_read_tool = DirectoryReadTool()
file_read_tool = FileReadTool()
scrape_tool = ScrapeWebsiteTool()
website_search_tool = WebsiteSearchTool()
exa_search_tool = EXASearchTool()

"""## Podcast Content Format"""

from pydantic import BaseModel
# Define a Pydantic model for venue details
# (demonstrating Output as Pydantic)
class PodcastContent(BaseModel):
    title: str
    description: str
    prompt: str
    audio_link:str
    paper_link:str

# Define a Pydantic model for venue details
# (demonstrating Output as Pydantic)
class FullPaperText(BaseModel):
    full_text:str

"""## Agent
researcher:
  role: >
    Senior Researcher and Editor
  goal: >
    Uncover cutting-edge developments and pick the top theme for podcast
  backstory: >
    You're a seasoned researcher with a knack for uncovering the latest
    developments. Known for your ability to find the most relevant
    information and present it in a clear and concise manner.

writer:
  role: >
    Senior content writer
  goal: >
    write great content for podcast
  backstory: >
    You're a seasoned content writer with a knack for uncovering the latest
    developments. you can write very good text for the podcast.
"""

paper_finder_agent = Agent (
    role="Senior AI Researcher",
    goal="Uncover cutting-edge AI trending and pick the top theme for podcast",
    backstory=(
        "As a part of the dynamic podcast team, "
        "You're a seasoned researcher with a knack for uncovering the latest AI developments."
        "Known for your ability to find the most relevant information and present it in a clear and concise manner."
        "Your work is crucial in paving the way "
        "for meaningful engagements and driving the company's growth."
    ),
    allow_delegation=False,
    verbose=True
)

researcher_agent = Agent(
    role="Senior AI Editor",
    goal="Uncover cutting-edge AI trending and pick the top theme for podcast",
    backstory=(
        "As a part of the dynamic podcast team, "
        "You're a seasoned researcher with a knack for uncovering the latest AI developments."
        "Known for your ability to find the most relevant information and present it in a clear and concise manner."
        "Your work is crucial in paving the way "
        "for meaningful engagements and driving the company's growth."
    ),
    allow_delegation=False,
    verbose=True
)

writer_agent = Agent(
    role="Senior content writer",
    goal="write great content for podcast",
    backstory=(
        "As a part of the dynamic podcast team, "
        "You're a seasoned content writer with a knack for uncovering the latest AI developments."
        "you can write very good content for the podcast."
        "Your work is crucial in paving the way "
        "for meaningful engagements and driving the company's growth."
    ),
    allow_delegation=False,
    verbose=True
)

"""## Tasks

research_task:
  description: >
    Pick one paper from database,
    not just based on the publish date and total Citations,
    but also think about interesting and impact to podcast lisener
  expected_output: >
    pick one paper
  agent: researcher

write_task:
  description: >
    Write podcast title and podcast description for the selected paper,
    make sure the catche for podcast viewer.
    add paper tile, link, publish date and authors at the end of description.
  expected_output: >
    podcast title and podcast description.
    Formatted as markdown without '```'
  agent: writer

"""

find_paper_task = Task(
    description=(
        "search for the latest papers about the given {topic},"
        "category is 'research paper',"
        "startPublishedDate is current year to date (2024)"
        "num_results=5"
    ),
    expected_output=(
        "get 5 papers from results from category of 'research paper, with link"
    ),
    tools=[exa_search_tool],
    agent=paper_finder_agent,
)

research_task = Task(
    description=(
        "Rank the papers from find_paper_task, not just based on the publish date and total Citations,"
        "but also think about interesting and impact to podcast lisener"
        "give them score"
        "take human input as picked topic and send it to writer_agent"
    ),
    expected_output=(
        "use human input as final choice"
    ),
    agent=researcher_agent,
    human_input=True
    )

validate_task = Task(
    description=(
        "check all these new links if it's working"
        "suggeste one paper with working link"
    ),
    expected_output=(
        "one paper with a replaced link from 'abs' to 'html'"
    ),
    agent=researcher_agent,
    tools=[website_search_tool]
    )


write_task = Task(
    description=(
        "Write podcast title and podcast description,"
        "based on the scraped content from the scrape_full_text_task or the original link,"
        "from the selected paper HTML link."
        "make sure the catche for podcast viewer."

    ),
    expected_output=(
        "provide title, description and prompt text for NLM"
        "add paper tile, link, publish date and authors at the end of description."
        "total English characters count should be less than 400."
        "add a prompt text, less than 100, short intro to podcast host, how should they talk about this paper."
    ),
    agent=writer_agent,
    tools=[scrape_tool],
    output_json=PodcastContent,
    output_file="podcast_content.json",
)

scrape_full_text_task = Task(
    description=(
         "replace the 'abs' in these paper website link to 'HTML',"
        "scrape the full text from the html link except References part"
    ),
    expected_output=(
        "add full scrapted text content from HTML link to full_txt."
        "except References part."
    ),
    agent=writer_agent,
    tools=[scrape_tool],
    output_json=FullPaperText,
    output_file="FullPaperText.json",
)

"""## Crew"""

# Define the crew with agents and tasks
newsroom_crew = Crew(
    agents=[
            paper_finder_agent,
            researcher_agent,
            writer_agent
            ],
    tasks=[
            find_paper_task,
            research_task,
            write_task
           ],
    verbose=True,
	  memory=True,
    planning = True
)

"""## Run Crew"""

inputs = {
    'topic': "AI music"
    }

result = newsroom_crew.kickoff(inputs=inputs)

"""## Display Json file"""

import json
from pprint import pprint

with open('podcast_content.json') as f:
   data = json.load(f)

pprint(data)

"""# Publish Process

## Phrase Json
"""

import json

# Step 1: Extracting JSON content from a file into a Python dictionary
def load_podcast_content():
    with open('/content/podcast_content.json', 'r') as file:
        return json.load(file)

global_podcast_content = load_podcast_content()

# Step 2: Accessing data globally
# Example usage of the global variable
podcast_title = global_podcast_content["title"]
podcast_description = global_podcast_content["description"]
podcast_prompt = global_podcast_content["prompt"]
paper_link = global_podcast_content["paper_link"].replace("abs", "pdf")
audio_link = global_podcast_content["audio_link"]

print (paper_link)

"""## Define NLM Request"""

import requests

class NotebookLMClient:
    def __init__(self, api_token):
        self.api_url = 'https://api.autocontentapi.com/content/create'
        self.status_url = 'https://api.autocontentapi.com/content/status/'  # Assuming this is the status endpoint
        self.headers = {
            'Authorization': f'Bearer {api_token}',
            'accept': 'application/json',
            'Content-Type': 'application/json'
        }

    def send_content(self, resources, text, output_type="audio"):
        data = {
            "resources": resources,
            "text": text,
            "outputType": output_type
        }
        response = requests.post(self.api_url, headers=self.headers, json=data)
        if response.ok:
            result = response.json()
            print("Request sent successfully. Request ID:", result.get("request_id"))
            return result.get("request_id")  # Return the request_id for status tracking
        else:
            print("Error:", response.text)
            return None

    def check_status(self, request_id):
        status_endpoint = f"{self.status_url}/{request_id}"
        response = requests.get(status_endpoint, headers=self.headers)
        if response.ok:
            status_data = response.json()
            # Display relevant status information
            print("Status:", status_data.get("status"))
            print("Updated On:", status_data.get("updated_on"))
            print("Error Message:", status_data.get("error_message"))
            print("Audio URL:", status_data.get("audio_url"))
            print("Response Text:", status_data.get("response_text"))
            return status_data
        else:
            print("Error checking status:", response.text)
            return None

"""## Send Text to NLM"""

# Example usage
client = NotebookLMClient(userdata.get('NotebookLM_API_KEY'))

# Define resources and text content
resources = [
    {"content": podcast_description, "type": "text"},
    {"content": paper_link, "type": "website"},

]
text = podcast_prompt

# Send content to the API and get the request ID
request_id = client.send_content(resources, text)

# Check the status of the request
if request_id:
    status_data = client.check_status(request_id)

print (podcast_description)
print (paper_link)
print (podcast_title)

"""## Check Status"""

import time
import json

def check_status_until_complete(client, request_id):
    while True:
        # 获取状态数据
        status_data = client.check_status(request_id)
        status = status_data.get("status")
        updated_on = status_data.get("updated_on")
        error_message = status_data.get("error_message")
        audio_url = status_data.get("audio_url")

        print(f"检查状态中... 状态码: {status}, 更新时间: {updated_on}, 错误信息: {error_message}")

        # 如果状态码是 100（成功）或者 60（失败），退出循环
        if status == 100:
            print("任务成功完成，获取到音频链接。")
            # 将音频 URL 存储到 JSON 文件
            if audio_url:
                return audio_url
            break
        elif status == 60:
            print("任务失败，请检查错误信息。")
            break

        # 等待 30 秒后再次检查状态
        time.sleep(30)
# 将音频 URL 提取并存入 JSON 文件
audio_url = check_status_until_complete(client, request_id)

print (audio_url)

import requests
from pydub import AudioSegment

# 下载音频文件 (.wav)
def download_audio(audio_url, output_path):
    response = requests.get(audio_url, stream=True)
    if response.status_code == 200:
        with open(output_path, 'wb') as audio_file:
            for chunk in response.iter_content(chunk_size=1024):
                audio_file.write(chunk)
        print(f"音频文件已下载并保存为 {output_path}")
    else:
        print(f"下载音频文件失败，状态码：{response.status_code}")

# 将 .wav 文件转换为 .mp3 文件
def convert_wav_to_mp3(wav_path, mp3_path):
    audio = AudioSegment.from_wav(wav_path)
    audio.export(mp3_path, format="mp3")
    print(f"已将音频文件从 {wav_path} 转换为 {mp3_path}")

# 设定路径
audio_url = audio_url
wav_path = "downloaded_audio.wav"
mp3_path = "converted_audio.mp3"

# 执行下载和转换操作
download_audio(audio_url, wav_path)
convert_wav_to_mp3(wav_path, mp3_path)

"""## Define Podbean Request"""

class PodbeanUploader:
    def __init__(self, client_id, client_secret):
        self.client_id = client_id
        self.client_secret = client_secret
        self.auth_url = "https://api.podbean.com/v1/oauth/token"
        self.authorize_upload_url = "https://api.podbean.com/v1/files/uploadAuthorize"
        self.publish_url = "https://api.podbean.com/v1/episodes"
        self.access_token = self.get_access_token()

    def get_access_token(self):
        # Step 1: Request an access token from Podbean
        auth_data = {
            'grant_type': 'client_credentials',
            'client_id': self.client_id,
            'client_secret': self.client_secret
        }
        response = requests.post(self.auth_url, data=auth_data)
        if response.ok:
            token_info = response.json()
            print("Access token obtained successfully.")
            return token_info['access_token']
        else:
            print("Failed to get access token:", response.text)
            return None

    def authorize_file_upload(self, filename, file_path, content_type="audio/mpeg"):
        # Step 2: Get the presigned URL and file_key
        filesize = os.path.getsize(file_path)
        params = {
            'access_token': self.access_token,
            'filename': filename,
            'filesize': filesize,
            'content_type': content_type
        }
        headers = {
            'User-Agent': 'MyApp/1.2.3 (Example)'
        }
        response = requests.get(self.authorize_upload_url, headers=headers, params=params)
        if response.ok:
            return response.json()
        else:
            print("Failed to authorize file upload:", response.text)
            return None

    def upload_file_to_presigned_url(self, presigned_url, file_path):
        # Step 3: Upload the file to the presigned URL
        with open(file_path, 'rb') as file_data:
            headers = {'Content-Type': 'audio/mpeg'}
            response = requests.put(presigned_url, headers=headers, data=file_data)
            if response.status_code == 200:
                print("File uploaded successfully.")
                return True
            else:
                print("Failed to upload file:", response.text)
                return False

    def publish_episode(self, title, content, file_key, season_number=1, episode_number=1):
        # Step 4: Publish the episode using file_key as media_key
        data = {
            'access_token': self.access_token,
            'title': title,
            'content': content,
            'status': 'publish',
            'type': 'public',
            'media_key': file_key,
            'season_number': season_number,
            'episode_number': episode_number,
            'apple_episode_type': 'full',
            'content_explicit': 'clean'
        }

        headers = {
            'User-Agent': 'AI Paper+/1.0 (Example)'
        }

        response = requests.post(self.publish_url, headers=headers, data=data)
        if response.ok:
            print("Episode published successfully!")
            return response.json()
        else:
            print("Failed to publish episode:", response.text)
            return None

"""## Publish to Podbean"""

# Usage example
podbean = PodbeanUploader(userdata.get('podbean_client_id'), userdata.get('podbean_client_secret'))

# Step 1: Authorize file upload to get presigned URL and file_key
filename = "converted_audio.mp3"
file_path = mp3_path  # Make sure this is an mp3 file
authorize_response = podbean.authorize_file_upload(filename, file_path)

if authorize_response:
    presigned_url = authorize_response['presigned_url']
    file_key = authorize_response['file_key']
    print("Presigned URL:", presigned_url)
    print("File Key:", file_key)

    # Step 2: Upload file to presigned URL
    upload_success = podbean.upload_file_to_presigned_url(presigned_url, file_path)

    # Step 3: Publish episode if upload was successful
    if upload_success:
        title = podcast_title
        content = (
         podcast_description
        )
        publish_response = podbean.publish_episode(title, content, file_key)

        if publish_response:
            print("Response:", publish_response)